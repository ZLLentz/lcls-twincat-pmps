<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_BPTM_Test" Id="{fb9a456e-191d-4018-903c-95799c9aa22a}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_BPTM_Test EXTENDS TcUnit.FB_TestSuite
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
VAR CONSTANT
    BPTM_ARR : UDINT := PMPS_GVL.MAX_ASSERTIONS;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[BPTMBasicFunction();
//InterruptedTransition();
FullArbError();]]></ST>
    </Implementation>
    <Method Name="BPTMBasicFunction" Id="{70f68025-dfe3-432b-8778-ea5b6ded4985}">
      <Declaration><![CDATA[METHOD BPTMBasicFunction
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 1;
    stTransitionAssertion    :    ST_BeamParams := (nRate := 10);
    
    nReqID    :    UDINT    := 2;
    stReqAssertion    :    ST_BeamParams := (nTran := 20);
    
END_VAR
VAR_INST
    fbBPTM_TestBasicFunction    :    BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Completes arbiter request elevation process
// Necessary for CheckRequest to return true, ever
    fbBPTM_TestBasicFunction(
        fbArbiter := fbArbiter,
        stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback);

fbSubSysIO(LA := fbArbiter, FFO := ffo);

CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTMTest');
    eTestStep := E_BPTMTestStates.WaitingForBeam;

E_BPTMTestStates.WaitingForBeam:
    TEST('BPTM Waits for Beam');
    
    fbBPTM_TestBasicFunction.i_TransitionAssertionID := nTransitionID;
    fbBPTM_TestBasicFunction.i_stTransitionAssertion := stTransitionAssertion;
    
    fbBPTM_TestBasicFunction.i_nRequestedAssertionID := nReqID;
    fbBPTM_TestBasicFunction.i_stRequestedAssertion := stReqAssertion;
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.WaitForBP AND 
        NOT fbBPTM_TestBasicFunction.xEntry THEN
    
        AssertTrue(fbArbiter.CheckRequestInPool(nTransitionID), 'Arbiter did not accept BPTM transition assertion');
        
        AssertTrue(fbArbiter.CheckRequestInPool(nReqID), 'Arbiter did not accept BPTM transition assertion');
                
        AssertFalse(fbBPTM_TestBasicFunction.q_xTransitionAuthorized,
            'Transition should not be authorized until requests are in and beam is ready');
            
        AssertTrue(fbBPTM_TestBasicFunction.bBusy, 'Busy should be true here');
        AssertFalse(fbBPTM_TestBasicFunction.bDone, 'Done should be false');
        AssertFalse(fbBPTM_TestBasicFunction.bError, 'Error should be false here');
            
        TEST_FINISHED_NAMED('BPTM Waits for Beam');
        
        eTestStep := E_BPTMTestStates.Transitioning;
    END_IF


E_BPTMTestStates.Transitioning:
    TEST('BPTM Authorizes Transition');

    fbSubSysIO.ApplyBPReq(TRUE);    
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.Transitioning AND
        NOT fbBPTM_TestBasicFunction.xEntry THEN
    
        AssertTrue(fbArbiter.CheckRequest(nReqID),
            'Transition assertion should be in arbiter');
        
        AssertTrue(fbArbiter.CheckRequest(nReqID),
            'Final assertion should be in arbiter');
            
        AssertTrue(fbBPTM_TestBasicFunction.q_xTransitionAuthorized,
            'Transition should be authorized at this point.');
            
        AssertEquals(nReqID, fbBPTM_TestBasicFunction.nCurrentAssertionID,
            'nCurrentAssertionID not set.');
    
        TEST_FINISHED_NAMED('BPTM Authorizes Transition');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
    END_IF

E_BPTMTestStates.CleaningUp:

    TEST('Cleaning up');
    
    fbBPTM_TestBasicFunction.i_xDoneMoving := TRUE;
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.Done THEN
        
        AssertFalse(fbArbiter.CheckRequestInPool(nTransitionID), 'Transition req should be removed from arb now');
        
        eTestStep := E_BPTMTestStates.Done; 
        
        TEST_FINISHED_NAMED('Cleaning up');
	END_IF

E_BPTMTestStates.Done:

    
    AssertTrue(fbBPTM_TestBasicFunction.bDone, 'Done should be set');
    AssertFalse(fbBPTM_TestBasicFunction.bError, 'Error should be cleared');
    AssertFalse(fbBPTM_TestBasicFunction.bBusy, 'Busy should be false');
    
    TEST_FINISHED_NAMED('BPTMTest');    
    
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FullArbError" Id="{b24cff8a-98df-48c0-95b3-ca157e608fb9}">
      <Declaration><![CDATA[// Simulate error due to full arbiter
METHOD FullArbError
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 1000;
    stTransitionAssertion    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    nReqID    :    UDINT    := 2000;
    stReqAssertion    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    idx : UDINT;
    
    nRandID : DWORD;
    testReq : ST_BeamParams := (neVRange := 16#FFEE, nRate:=33);
    
END_VAR
VAR_INST
    fbBPTM_TestFullArb    :    BeamParameterTransitionManager;
    fbArbFullErr    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
    entryToRetry : bool := true;
    fbRand : DRAND := (Seed :=1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTMErrorFullArb');
    
    // Fill the arbiter
    FOR idx := 1 TO PMPS_GVL.MAX_ASSERTIONS // this fills the arbiter
                    - fbBPTM_TestFullArb.cReqArbCapacity + 1 DO // but test just one over the allowed amount
        fbArbFullErr.AddRequest(nReqID := idx, stReqBP := testReq);
    END_FOR
    
    fbSubSysIO.AutoUpdateBP := TRUE;
    
    AssertTrue(PMPS_GVL.MAX_ASSERTIONS - fbArbFullErr.nEntryCount < fbBPTM_TestFullArb.cReqArbCapacity,
        'Arbiter is not full enough, rest of tests will be invalid'); 
    
    eTestStep := E_BPTMTestStates.Error;

E_BPTMTestStates.Error:
    
    TEST('BPTM Full Error');

    IF fbBPTM_TestFullArb.bError THEN
        
        AssertTrue(fbBPTM_TestFullArb.bError AND fbBPTM_TestFullArb.nErrId = PMPS_CODES.NoRoomInArb,
            'Incorrect error response from full arbiter.');
            
        TEST_FINISHED_NAMED('BPTM Full Error');
        
        eTestStep := E_BPTMTestStates.Retry;
        
	END_IF
    
E_BPTMTestStates.Retry:
    
    TEST('Test Retry Post Failed Final');
    
    // Clear the arbiter
    if entryToRetry THEN
        FOR idx := 1 TO PMPS_GVL.MAX_ASSERTIONS + 1 DO
            fbArbFullErr.RemoveRequest(idx);
        END_FOR
        entryToRetry := FALSE;
    END_IF
    
    // Push the retry button
    fbBPTM_TestFullArb.bRetry := TRUE;
    
    tonRetryTimeout(IN:=TRUE);
    
    IF tonRetryTimeout.Q OR fbBPTM_TestFullArb.q_xTransitionAuthorized THEN
        AssertTrue(fbBPTM_TestFullArb.q_xTransitionAuthorized, 'Transition should have been authorized by now');
        AssertTrue(fbArbFullErr.CheckRequest(nTransitionID), 'Transition ID is missing from arbiter while transition is authorized');
        AssertTrue(fbArbFullErr.CheckRequest(nReqID), 'Final ID is missing from arbiter while transition is authorized');
        
        TEST_FINISHED_NAMED('Test Retry Post Failed Final');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
	END_IF

E_BPTMTestStates.CleaningUp:
    TEST_FINISHED_NAMED('BPTMErrorFullArb');    
    
END_CASE

fbBPTM_TestFullArb(
    fbArbiter := fbArbFullErr,
    i_TransitionAssertionID := nTransitionID,
    i_stTransitionAssertion := stTransitionAssertion,
    
    i_nRequestedAssertionID := nReqID,
    i_stRequestedAssertion := stReqAssertion,
    
    stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback,
);

fbSubSysIO(LA := fbArbFullErr, FFO := ffo);]]></ST>
      </Implementation>
    </Method>
    <Method Name="InterruptAtAllSteps" Id="{57f1a367-2f35-4862-95b6-e41c9bfb9e3f}">
      <Declaration><![CDATA[// Test the BPTM seamlessly handles new requests at any stage
// Verify old requests are removed from arbiter
METHOD InterruptAtAllSteps
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 3;
    stTranReq    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    nFirstReqID    :    UDINT    := 1;
    stFirstReq    :    ST_BeamParams := (nRate := 100);
    
    nSecondReqID    :    UDINT    := 2;
    stSecReq    :    ST_BeamParams := (nRate:= 200);
    
END_VAR
VAR_INST
    fbBPTM_InterruptionTest    :    BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTM Intr Trans');
    
    fbBPTM_InterruptionTest.i_TransitionAssertionID := nTransitionID;
    fbBPTM_InterruptionTest.i_stTransitionAssertion := stTranReq;
    
    fbBPTM_InterruptionTest.i_nRequestedAssertionID := nFirstReqID;
    fbBPTM_InterruptionTest.i_stRequestedAssertion := stFirstReq;
    
    fbSubSysIO.AutoUpdateBP := TRUE; // Enable auto update
    
    eTestStep := E_BPTMTestStates.WaitingForTransitionAssertion;

E_BPTMTestStates.WaitingForTransitionAssertion:

    IF fbBPTM_InterruptionTest.eBPTMState = E_BPTMState.WaitingForTransitionAssertion AND 
        NOT fbBPTM_InterruptionTest.xEntry THEN // since we're not in entry anymore 
    
        //change the request to interrupt
        fbBPTM_InterruptionTest.i_nRequestedAssertionID := nSecondReqID;
        fbBPTM_InterruptionTest.i_stRequestedAssertion := stSecReq;
        
        eTestStep := E_BPTMTestStates.Transitioning;
    END_IF
    
E_BPTMTestStates.Transitioning:
    
    TEST('New Target Gets To Trans Auth');
    
    tonRetryTimeout(IN:=TRUE);
    
    IF tonRetryTimeout.Q OR fbBPTM_InterruptionTest.q_xTransitionAuthorized THEN
        AssertTrue(fbBPTM_InterruptionTest.q_xTransitionAuthorized, 'Transition should have been authorized by now');
        AssertTrue(fbArbiter.CheckRequest(nTransitionID), 'Transition ID is missing from arbiter while transition is authorized');
        AssertTrue(fbArbiter.CheckRequest(nSecondReqID), 'Final ID is missing from arbiter while transition is authorized');
        
        TEST_FINISHED_NAMED('New Target Gets To Trans Auth');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
	END_IF

E_BPTMTestStates.CleaningUp:
    TEST_FINISHED_NAMED('BPTM Intr Trans');    
    
END_CASE

fbBPTM_InterruptionTest(
    fbArbiter := fbArbiter,
    stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback
);

fbSubSysIO(LA := fbArbiter, FFO := ffo);]]></ST>
      </Implementation>
    </Method>
    <Method Name="InterruptedTransition" Id="{52bafcb8-58c7-428b-9676-0a0ae9d5b89b}">
      <Declaration><![CDATA[// Test the BPTM seamlessly handles new requests at any stage
// Verify old requests are removed from arbiter
METHOD InterruptedTransition
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 3;
    stTranReq    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    nFirstReqID    :    UDINT    := 1;
    stFirstReq    :    ST_BeamParams := (nRate := 100);
    
    nSecondReqID    :    UDINT    := 2;
    stSecReq    :    ST_BeamParams := (nRate:= 200);
    
END_VAR
VAR_INST
    fbBPTM_InterruptionTest    :    BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTM Intr Trans');
    
    fbBPTM_InterruptionTest.i_TransitionAssertionID := nTransitionID;
    fbBPTM_InterruptionTest.i_stTransitionAssertion := stTranReq;
    
    fbBPTM_InterruptionTest.i_nRequestedAssertionID := nFirstReqID;
    fbBPTM_InterruptionTest.i_stRequestedAssertion := stFirstReq;
    
    fbSubSysIO.AutoUpdateBP := TRUE; // Enable auto update
    
    eTestStep := E_BPTMTestStates.WaitingForTransitionAssertion;

E_BPTMTestStates.WaitingForBeam:

    IF fbBPTM_InterruptionTest.eBPTMState = E_BPTMState.WaitingForTransitionAssertion AND 
        NOT fbBPTM_InterruptionTest.xEntry THEN // since we're not in entry anymore 
    
        //change the request to interrupt
        fbBPTM_InterruptionTest.i_nRequestedAssertionID := nSecondReqID;
        fbBPTM_InterruptionTest.i_stRequestedAssertion := stSecReq;
        
        eTestStep := E_BPTMTestStates.Transitioning;
    END_IF
    
E_BPTMTestStates.Transitioning:
    
    TEST('New Target Gets To Trans Auth');
    
    tonRetryTimeout(IN:=TRUE);
    
    IF tonRetryTimeout.Q OR fbBPTM_InterruptionTest.q_xTransitionAuthorized THEN
        AssertTrue(fbBPTM_InterruptionTest.q_xTransitionAuthorized, 'Transition should have been authorized by now');
        AssertTrue(fbArbiter.CheckRequest(nTransitionID), 'Transition ID is missing from arbiter while transition is authorized');
        AssertTrue(fbArbiter.CheckRequest(nSecondReqID), 'Final ID is missing from arbiter while transition is authorized');
        
        TEST_FINISHED_NAMED('New Target Gets To Trans Auth');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
	END_IF

E_BPTMTestStates.CleaningUp:
    TEST_FINISHED_NAMED('BPTM Intr Trans');    
    
END_CASE

fbBPTM_InterruptionTest(
    fbArbiter := fbArbiter,
    stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback
);

fbSubSysIO(LA := fbArbiter, FFO := ffo);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>